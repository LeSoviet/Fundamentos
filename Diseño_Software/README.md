# Dise√±o de Software

El dise√±o de software es el proceso de **planificar y estructurar** una aplicaci√≥n antes de escribir el c√≥digo. Piensa en ello como los **planos arquitect√≥nicos** para construir una casa: sin buenos planos, la casa ser√° d√©bil, dif√≠cil de mantener, y costosa de reparar.

## üìö Contenido de esta Secci√≥n

1. [Principios SOLID](./SOLID_Principles.md) - Cinco principios fundamentales de dise√±o orientado a objetos
2. [Patrones de Dise√±o](./Patrones_Diseno.md) - Soluciones reutilizables a problemas comunes
3. [Arquitectura de Software](./Arquitectura_Software.md) - Estructuraci√≥n a gran escala de aplicaciones

## üèóÔ∏è ¬øPor Qu√© es Importante el Dise√±o de Software?

### üéØ Analog√≠a: Construir una Casa
Imagina que quieres construir una casa:

**‚ùå Sin dise√±o (solo empezar a construir):**
- Pones las paredes donde te parece
- No planeas d√≥nde ir√°n los ba√±os
- La electricidad queda en lugares extra√±os
- Si quieres a√±adir una habitaci√≥n, tienes que demoler paredes
- La casa es ineficiente, fea y peligrosa

**‚úÖ Con buen dise√±o (planos arquitect√≥nicos):**
- Sabes exactamente d√≥nde ir√° cada habitaci√≥n
- La electricidad y plomer√≠a est√°n bien planeadas
- Es f√°cil a√±adir habitaciones m√°s tarde
- La casa es segura, eficiente y bonita
- El mantenimiento es sencillo

### üí° Beneficios Reales en Programaci√≥n:
1. **Ahorro de tiempo**: Menos tiempo corrigiendo errores
2. **C√≥digo m√°s limpio**: M√°s f√°cil de leer y entender
3. **Facilidad para cambios**: A√±adir nuevas funcionalidades sin romper lo existente
4. **Trabajo en equipo**: Varios desarrolladores pueden trabajar juntos sin chocar
5. **Menos estr√©s**: Sabes qu√© hacer y c√≥mo hacerlo

## üéì Conceptos Fundamentales para Principiantes

### üß© Modularidad: Divide y Vencer√°s
**¬øQu√© es?** Dividir un problema grande en piezas peque√±as y manejables.

**Analog√≠a:** En lugar de intentar construir una casa entera de una vez, construyes:
- Los cimientos primero
- Luego las paredes
- Despu√©s el techo
- Finalmente la decoraci√≥n

Cada pieza es independiente pero trabaja con las dem√°s.

**En c√≥digo:**
```javascript
// Mal: Todo junto en una funci√≥n gigante
function procesarPedidoCompleto(pedido) {
    // Validar datos (50 l√≠neas)
    // Calcular precio (30 l√≠neas)
    // Guardar en base de datos (40 l√≠neas)
    // Enviar email (25 l√≠neas)
    // Actualizar inventario (35 l√≠neas)
    // Total: 180 l√≠neas en una funci√≥n
}

// Bien: Dividido en m√≥dulos peque√±os
function validarPedido(pedido) { /* 20 l√≠neas */ }
function calcularPrecio(pedido) { /* 15 l√≠neas */ }
function guardarPedido(pedido) { /* 20 l√≠neas */ }
function enviarConfirmacion(pedido) { /* 10 l√≠neas */ }
function actualizarInventario(pedido) { /* 15 l√≠neas */ }

function procesarPedidoCompleto(pedido) {
    validarPedido(pedido);
    let precio = calcularPrecio(pedido);
    guardarPedido(pedido);
    enviarConfirmacion(pedido);
    actualizarInventario(pedido);
}
```

### üîå Acoplamiento: Qu√© Tan Conectados Est√°n los Componentes
**¬øQu√© es?** Mide cu√°nto dependen unas piezas de otras.

**Analog√≠a:**
- **Alto acoplamiento**: Como si tu tel√©fono, televisor y nevera dejaran de funcionar si se va la luz (todo depende de una sola cosa)
- **Bajo acoplamiento**: Como si cada aparato funcionara independientemente con su propia bater√≠a

**En c√≥digo:**
```javascript
// Alto acoplamiento (mal)
class Usuario {
    constructor() {
        this.baseDeDatos = new MySQLDatabase("localhost"); // Dependencia directa
    }
    
    guardar() {
        this.baseDeDatos.insert(this); // Solo funciona con MySQL
    }
}

// Bajo acoplamiento (bien)
class Usuario {
    constructor(repositorio) { // Inyecci√≥n de dependencia
        this.repositorio = repositorio;
    }
    
    guardar() {
        this.repositorio.guardar(this); // Funciona con cualquier repositorio
    }
}

// Puede usar MySQL, PostgreSQL, MongoDB, etc.
let usuarioMySQL = new Usuario(new MySQLRepositorio());
let usuarioMongo = new Usuario(new MongoRepositorio());
```

### üéØ Cohesi√≥n: Qu√© Tan Enfocada Est√° una Pieza
**¬øQu√© es?** Mide cu√°n relacionadas est√°n las partes dentro de un mismo componente.

**Analog√≠a:**
- **Alta cohesi√≥n**: Una caja de herramientas donde cada herramienta tiene un prop√≥sito espec√≠fico
- **Baja cohesi√≥n**: Una caja donde mezclas herramientas de cocina, jardiner√≠a y mec√°nica

**En c√≥digo:**
```javascript
// Baja cohesi√≥n (mal)
class SistemaUsuarios {
    // M√©todos para usuarios
    crearUsuario() { }
    eliminarUsuario() { }
    
    // M√©todos para email (no relacionado)
    enviarEmail() { }
    validarEmail() { }
    
    // M√©todos para reportes (no relacionado)
    generarReporteVentas() { }
    exportarPDF() { }
}

// Alta cohesi√≥n (bien)
class UsuarioService {
    // Solo m√©todos relacionados con usuarios
    crearUsuario() { }
    eliminarUsuario() { }
    actualizarUsuario() { }
    buscarUsuario() { }
}

class EmailService {
    // Solo m√©todos relacionados con email
    enviarEmail() { }
    validarEmail() { }
}

class ReporteService {
    // Solo m√©todos relacionados con reportes
    generarReporteVentas() { }
    exportarPDF() { }
}
```

### üìã Abstracci√≥n: Ocultar Detalles Complejos
**¬øQu√© es?** Mostrar solo lo necesario y esconder los detalles complicados.

**Analog√≠a:** Cuando conduces un coche:
- Solo necesitas saber usar el volante, pedales y cambios
- No necesitas saber c√≥mo funciona el motor internamente
- El coche **abstrae** la complejidad del motor

**En c√≥digo:**
```javascript
// Sin abstracci√≥n (complejo para el usuario)
let conexion = new DatabaseConnection();
conexion.connect("localhost", "user", "pass");
let resultado = conexion.query("SELECT * FROM usuarios WHERE id = ?", [1]);
conexion.close();

// Con abstracci√≥n (simple para el usuario)
class UsuarioRepositorio {
    constructor() {
        // Detalles de conexi√≥n ocultos
        this.db = new DatabaseConnection();
    }
    
    buscarPorId(id) {
        // L√≥gica compleja oculta
        return this.db.query("SELECT * FROM usuarios WHERE id = ?", [id]);
    }
}

// El usuario solo necesita esto:
let repo = new UsuarioRepositorio();
let usuario = repo.buscarPorId(1); // Simple y claro
```

## üèóÔ∏è Principios Fundamentales del Dise√±o de Software

### SOLID Principles
Conjunto de cinco principios de dise√±o orientados a objetos:

1. **Single Responsibility Principle (SRP)**
   - Una clase debe tener una sola raz√≥n para cambiar
   - Cada clase debe tener una √∫nica responsabilidad

2. **Open/Closed Principle (OCP)**
   - Las entidades de software deben estar abiertas para extensi√≥n pero cerradas para modificaci√≥n
   - Extiende funcionalidades sin modificar c√≥digo existente

3. **Liskov Substitution Principle (LSP)**
   - Los objetos de una superclase deben poder ser reemplazados por objetos de una subclase sin afectar la correcci√≥n del programa

4. **Interface Segregation Principle (ISP)**
   - Muchas interfaces espec√≠ficas son mejores que una interfaz general
   - Evita interfaces sobrecargadas

5. **Dependency Inversion Principle (DIP)**
   - Depende de abstracciones, no de implementaciones concretas
   - M√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel

### DRY (Don't Repeat Yourself)
Evita la duplicaci√≥n de l√≥gica, conocimiento o informaci√≥n:
- Reutiliza c√≥digo mediante funciones, clases y m√≥dulos
- Centraliza configuraciones y constantes

### KISS (Keep It Simple, Stupid)
Mant√©n las cosas simples:
- Evita complejidad innecesaria
- Prefiere soluciones simples y directas

### YAGNI (You Aren't Gonna Need It)
No implementes funcionalidades hasta que sean necesarias:
- Evita sobreingenier√≠a
- Implementa solo lo que se necesita ahora

## üìê Patrones de Dise√±o

### Patrones Creacionales
Manejan la creaci√≥n de objetos:

- **Singleton**: Garantiza una √∫nica instancia de una clase
- **Factory Method**: Define una interfaz para crear objetos
- **Abstract Factory**: Crea familias de objetos relacionados
- **Builder**: Construye objetos complejos paso a paso
- **Prototype**: Crea objetos copiando prototipos existentes

### Patrones Estructurales
Organizan las relaciones entre entidades:

- **Adapter**: Permite que interfaces incompatibles trabajen juntas
- **Bridge**: Separa abstracci√≥n de implementaci√≥n
- **Composite**: Compone objetos en estructuras de √°rbol
- **Decorator**: A√±ade funcionalidades a objetos din√°micamente
- **Facade**: Proporciona una interfaz simplificada a un subsistema complejo

### Patrones de Comportamiento
Gestionan algoritmos y responsabilidades entre objetos:

- **Observer**: Define dependencias uno-a-muchos entre objetos
- **Strategy**: Define una familia de algoritmos intercambiables
- **Command**: Encapsula una solicitud como un objeto
- **State**: Permite que un objeto altere su comportamiento cuando cambia su estado
- **Template Method**: Define el esqueleto de un algoritmo en una operaci√≥n

## üó∫Ô∏è Arquitectura de Software

### Arquitecturas Populares

#### Arquitectura en Capas (Layered Architecture)
Separa la aplicaci√≥n en capas l√≥gicas:
- Presentaci√≥n
- L√≥gica de negocio
- Acceso a datos

#### Arquitectura Hexagonal (Ports and Adapters)
Separa el n√∫cleo de la aplicaci√≥n de los mecanismos externos:
- Puerto: interfaz definida por el n√∫cleo
- Adaptador: implementaci√≥n que conecta el puerto con mecanismos externos

#### Arquitectura Limpia (Clean Architecture)
Jerarqu√≠a de dependencias que apunta hacia el centro:
- Entidades
- Casos de uso
- Adaptadores de interfaz
- Frameworks y drivers

#### Microservicios
Arquitectura distribuida donde la aplicaci√≥n se divide en servicios peque√±os e independientes:
- Alta cohesi√≥n
- Bajo acoplamiento
- Escalabilidad independiente

## üß± Componentes y Modularidad

### Cohesi√≥n y Acoplamiento
- **Alta cohesi√≥n**: Elementos dentro de un m√≥dulo est√°n estrechamente relacionados
- **Bajo acoplamiento**: M√≥dulos tienen pocas dependencias entre s√≠

### Separaci√≥n de Preocupencias
Divide un programa en secciones distintas donde cada secci√≥n aborda una preocupaci√≥n separada:
- Interfaz de usuario
- L√≥gica de negocio
- Acceso a datos

### Inversi√≥n de Control (IoC)
Transfiere el control de objetos o porciones de un programa a un contenedor o framework:
- Inyecci√≥n de dependencias
- Contenedores de inversi√≥n de control

## üõ†Ô∏è Herramientas de Dise√±o

### Diagramas UML
Lenguaje est√°ndar para visualizar el dise√±o de sistemas:
- Diagramas de clases
- Diagramas de secuencia
- Diagramas de componentes
- Diagramas de despliegue

### Prototipado
Creaci√≥n de versiones preliminares para probar conceptos:
- Prototipos de baja fidelidad
- Prototipos de alta fidelidad

### Modelado de Dominio
Representaci√≥n visual del espacio del problema:
- Diagramas de entidad-relaci√≥n
- Mapas de contexto

## üìà C√≥mo Mejorar tus Habilidades de Dise√±o

1. **Estudia ejemplos de buen dise√±o**
   - Analiza c√≥digo de proyectos exitosos
   - Lee libros sobre arquitectura de software

2. **Practica el dise√±o antes de codificar**
   - Dibuja diagramas antes de escribir c√≥digo
   - Usa papel y l√°piz para bosquejar ideas

3. **Participa en revisiones de dise√±o**
   - Recibe retroalimentaci√≥n de colegas
   - Aprende de diferentes perspectivas

4. **Refactoriza continuamente**
   - Mejora el dise√±o a medida que aprendes
   - Elimina deuda t√©cnica

5. **Aprende de errores**
   - Analiza dise√±os fallidos
   - Entiende qu√© sali√≥ mal y por qu√©

## üéØ Ejercicios Pr√°cticos para Principiantes

### Ejercicio 1: Dise√±ar un Sistema de Gesti√≥n de Tareas
**Objetivo**: Aplicar modularidad y cohesi√≥n para crear un sistema simple.

**üìã Requisitos:**
- Crear tareas (t√≠tulo, descripci√≥n, fecha l√≠mite)
- Marcar tareas como completadas
- Listar tareas pendientes
- Eliminar tareas

**üèóÔ∏è Paso 1: Identificar los componentes**
Piensa en las diferentes "cajas" que necesitas:
```javascript
// Componente 1: Manejar los datos de las tareas
class Tarea {
    constructor(titulo, descripcion, fechaLimite) {
        this.titulo = titulo;
        this.descripcion = descripcion;
        this.fechaLimite = fechaLimite;
        this.completada = false;
        this.fechaCreacion = new Date();
    }
    
    marcarComoCompletada() {
        this.completada = true;
        this.fechaCompletado = new Date();
    }
}

// Componente 2: Gestionar la lista de tareas
class GestorTareas {
    constructor() {
        this.tareas = []; // Array para guardar todas las tareas
    }
    
    agregarTarea(tarea) {
        this.tareas.push(tarea);
    }
    
    obtenerTareasPendientes() {
        return this.tareas.filter(tarea => !tarea.completada);
    }
    
    eliminarTarea(id) {
        this.tareas = this.tareas.filter(tarea => tarea.id !== id);
    }
}

// Componente 3: Interfaz de usuario (consola para simplificar)
class TareaUI {
    constructor(gestorTareas) {
        this.gestor = gestorTareas;
    }
    
    mostrarMenu() {
        console.log("=== Sistema de Tareas ===");
        console.log("1. Crear tarea");
        console.log("2. Ver tareas pendientes");
        console.log("3. Completar tarea");
        console.log("4. Salir");
    }
    
    crearTarea() {
        let titulo = prompt("T√≠tulo de la tarea:");
        let descripcion = prompt("Descripci√≥n:");
        let fechaLimite = prompt("Fecha l√≠mite (YYYY-MM-DD):");
        
        let tarea = new Tarea(titulo, descripcion, fechaLimite);
        this.gestor.agregarTarea(tarea);
        console.log("‚úÖ Tarea creada exitosamente");
    }
}

// Componente 4: Programa principal
class App {
    constructor() {
        this.gestor = new GestorTareas();
        this.ui = new TareaUI(this.gestor);
    }
    
    iniciar() {
        console.log("üöÄ Iniciando Sistema de Tareas...");
        // L√≥gica principal de la aplicaci√≥n
    }
}

// Punto de entrada
let app = new App();
app.iniciar();
```

**ü§î Preguntas para reflexionar:**
1. ¬øPor qu√© separamos `Tarea`, `GestorTareas`, `TareaUI` y `App`?
2. ¬øQu√© pasar√≠a si quisi√©ramos cambiar la interfaz de consola a web?
3. ¬øC√≥mo har√≠amos para guardar las tareas en un archivo en lugar de memoria?

### Ejercicio 2: Refactorizar C√≥digo Mal Dise√±ado
**Objetivo**: Identificar problemas de dise√±o y aplicar principios SOLID.

**‚ùå C√≥digo con problemas:**
```javascript
class ProcesadorPedidos {
    procesarPedido(pedido) {
        // Validaci√≥n (responsabilidad 1)
        if (!pedido.email || !pedido.productos) {
            console.log("Pedido inv√°lido");
            return false;
        }
        
        // C√°lculo de precio (responsabilidad 2)
        let total = 0;
        for (let producto of pedido.productos) {
            total += producto.precio * producto.cantidad;
        }
        
        // Guardar en base de datos (responsabilidad 3)
        // Simulaci√≥n de guardado
        console.log("Guardando pedido en BD...");
        
        // Enviar email (responsabilidad 4)
        console.log("Enviando email a: " + pedido.email);
        
        // Actualizar inventario (responsabilidad 5)
        console.log("Actualizando inventario...");
        
        return true;
    }
}
```

**‚úÖ Tu misi√≥n**: Refactoriza este c√≥digo aplicando:
1. **Single Responsibility**: Divide la clase en clases m√°s peque√±as
2. **Open/Closed**: Haz que sea f√°cil a√±adir nuevos tipos de validaci√≥n
3. **Dependency Inversion**: Inyecta dependencias en lugar de crearlas

**üí° Pista**: Crea clases como:
- `ValidadorPedidos`
- `CalculadoraPrecios`
- `PedidoRepositorio`
- `EmailService`
- `InventarioService`

### Ejercicio 3: Dise√±ar un Sistema Simple con Patrones
**Objetivo**: Aplicar patrones de dise√±o b√°sicos.

**üìã Scenario**: Necesitas crear un sistema que genere diferentes tipos de reportes:
- Reporte PDF
- Reporte Excel  
- Reporte HTML

**üèóÔ∏è Aplica estos patrones:**

1. **Factory Method**: Para crear los diferentes reportes
2. **Strategy**: Para diferentes formatos de exportaci√≥n
3. **Template Method**: Para la estructura base de generaci√≥n

```javascript
// Paso 1: Interfaz base
class ReporteGenerator {
    generar(datos) {
        this.prepararDatos(datos);
        this.crearContenido();
        this.exportar();
    }
    
    prepararDatos(datos) {
        console.log("Preparando datos...");
        this.datos = datos;
    }
    
    // M√©todos abstractos que cada tipo implementar√°
    crearContenido() {
        throw new Error("Debe implementar crearContenido");
    }
    
    exportar() {
        throw new Error("Debe implementar exportar");
    }
}

// Paso 2: Implementaciones concretas
class PDFReporte extends ReporteGenerator {
    crearContenido() {
        console.log("Creando contenido PDF...");
    }
    
    exportar() {
        console.log("Exportando a PDF...");
    }
}

// Paso 3: Factory para crear reportes
class ReporteFactory {
    static crear(tipo) {
        switch(tipo) {
            case 'pdf':
                return new PDFReporte();
            case 'excel':
                return new ExcelReporte();
            case 'html':
                return new HTMLReporte();
            default:
                throw new Error("Tipo de reporte no soportado");
        }
    }
}

// Uso
let reportePDF = ReporteFactory.crear('pdf');
reportePDF.generar({titulo: "Ventas", datos: [1,2,3]});
```

## üöÄ Gu√≠a de Aprendizaje para Principiantes

### üìÖ Semana 1-2: Fundamentos
- **D√≠a 1-2**: Entiende modularidad (ejercicios de dividir funciones grandes)
- **D√≠a 3-4**: Practica cohesi√≥n y acoplamiento
- **D√≠a 5-7**: Aprende abstracci√≥n con ejemplos simples

### üìÖ Semana 3-4: Principios SOLID
- **D√≠a 1-3**: Single Responsibility y Open/Closed
- **D√≠a 4-5**: Liskov Substitution e Interface Segregation
- **D√≠a 6-7**: Dependency Inversion y pr√°ctica general

### üìÖ Semana 5-6: Patrones B√°sicos
- **D√≠a 1-3**: Patrones creacionales (Singleton, Factory)
- **D√≠a 4-6**: Patrones estructurales (Adapter, Decorator)
- **D√≠a 7**: Patrones de comportamiento (Strategy, Observer)

### üìÖ Semana 7-8: Arquitectura Simple
- **D√≠a 1-3**: Arquitectura en capas
- **D√≠a 4-5**: Principios de Clean Architecture
- **D√≠a 6-7**: Pr√°ctica con un proyecto peque√±o

## üéØ Checklist de Dise√±o para Principiantes

Antes de escribir c√≥digo, preg√∫ntate:

### ‚úÖ Modularidad
- [ ] ¬øHe dividido el problema en piezas peque√±as?
- [ ] ¬øCada pieza tiene una responsabilidad clara?
- [ ] ¬øPuedo probar cada pieza por separado?

### ‚úÖ Acoplamiento
- [ ] ¬øMis clases dependen de detalles espec√≠ficos?
- [ ] ¬øPuedo cambiar una pieza sin afectar a las dem√°s?
- [ ] ¬øEstoy inyectando dependencias en lugar de crearlas?

### ‚úÖ Cohesi√≥n  
- [ ] ¬øCada clase tiene un prop√≥sito bien definido?
- [ ] ¬øEst√°n relacionados todos los m√©todos de una clase?
- [ ] ¬øNo tengo "clases God" que hagan de todo?

### ‚úÖ Abstracci√≥n
- [ ] ¬øEstoy ocultando detalles complejos?
- [ ] ¬øLa interfaz es simple de usar?
- [ ] ¬øLos usuarios no necesitan conocer la implementaci√≥n interna?

## üîç Errores Comunes de Principiantes y C√≥mo Evitarlos

### üö´ Error 1: "Clases God"
**Problema**: Crear clases que hacen todo
```javascript
// Mal
class SistemaCompleto {
    // 500 l√≠neas que hacen todo
}
```
**Soluci√≥n**: Divide en clases peque√±as y enfocadas

### üö´ Error 2: Acoplamiento Fuerte
**Problema**: Todo depende de todo
```javascript
// Mal
class Usuario {
    constructor() {
        this.db = new MySQLDatabase(); // Dependencia directa
        this.email = new GmailService();  // Otra dependencia directa
    }
}
```
**Soluci√≥n**: Inyecta dependencias

### üö´ Error 3: No Pensar en Cambios Futuros
**Problema**: C√≥digo r√≠gido que no se puede modificar
```javascript
// Mal
if (tipo === "pdf") {
    // 100 l√≠neas de c√≥digo PDF
} else if (tipo === "excel") {
    // 100 l√≠neas de c√≥digo Excel
}
```
**Soluci√≥n**: Usa patrones como Factory o Strategy

## üèÜ Proyecto Final de Dise√±o

**Objetivo**: Dise√±ar y codificar un sistema peque√±o aplicando todo lo aprendido

### üìã Requisitos del Proyecto:
Crea un **Sistema de Biblioteca** con:
- Gesti√≥n de libros (t√≠tulo, autor, ISBN)
- Gesti√≥n de usuarios (nombre, email, tipo)
- Sistema de pr√©stamos (fechas, devoluciones)
- Generaci√≥n de reportes (libros prestados, usuarios morosos)
- Persistencia de datos (en archivo para simplificar)

### üéØ Criterios de evaluaci√≥n:
- **Modularidad**: ¬øEst√° bien dividido en componentes?
- **SOLID**: ¬øAplica los principios correctamente?
- **Patrones**: ¬øUsa patrones apropiados?
- **Extensibilidad**: ¬øEs f√°cil a√±adir nuevas funcionalidades?
- **Legibilidad**: ¬øEs f√°cil de entender y mantener?

**Recuerda**: El buen dise√±o no es sobre escribir c√≥digo complejo, sino sobre escribir c√≥digo **simple que funcione bien y sea f√°cil de cambiar**.